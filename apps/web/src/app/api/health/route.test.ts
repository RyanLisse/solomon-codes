/**
 * Tests for health check API endpoint
 * Using London TDD approach with comprehensive mocking
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { NextRequest } from 'next/server';

// Mock configuration service
const mockConfigService = {
  getConfiguration: vi.fn(),
  getDatabaseConfig: vi.fn(),
  getTelemetryConfig: vi.fn(),
  getLoggingConfig: vi.fn(),
  getServerConfig: vi.fn(),
};

vi.mock('@/lib/config/service', () => ({
  getConfigurationService: vi.fn(() => mockConfigService),
}));

// Import the module under test
import { GET, HEAD } from './route';

describe('Health Check API', () => {
  let originalEnv: NodeJS.ProcessEnv;
  let originalProcess: any;

  beforeEach(() => {
    // Save original environment and process
    originalEnv = { ...process.env };
    originalProcess = { ...process };

    // Set up test environment
    process.env.NODE_ENV = 'production';
    process.env.npm_package_version = '1.0.0';
    process.env.BUILD_TIME = '2024-01-01T00:00:00.000Z';
    process.env.SERVICE_NAME = 'test-service';

    // Mock process methods
    vi.spyOn(process, 'uptime').mockReturnValue(3600); // 1 hour uptime
    vi.spyOn(process, 'memoryUsage').mockReturnValue({
      rss: 100 * 1024 * 1024, // 100MB
      heapTotal: 80 * 1024 * 1024, // 80MB
      heapUsed: 60 * 1024 * 1024, // 60MB (75% usage)
      external: 5 * 1024 * 1024, // 5MB
      arrayBuffers: 2 * 1024 * 1024, // 2MB
    });

    // Mock configuration service responses
    mockConfigService.getConfiguration.mockReturnValue({
      nodeEnv: 'production',
      serviceName: 'test-service',
    });

    mockConfigService.getDatabaseConfig.mockReturnValue({
      url: 'postgres://test:password@localhost:5432/testdb',
      host: 'localhost',
    });

    mockConfigService.getTelemetryConfig.mockReturnValue({
      isEnabled: true,
      endpoint: 'http://localhost:4318/v1/traces',
    });

    mockConfigService.getLoggingConfig.mockReturnValue({
      level: 'info',
      serviceName: 'test-service',
      enableConsole: true,
      enableFile: false,
      enableOpenTelemetry: true,
    });

    mockConfigService.getServerConfig.mockReturnValue({
      environment: 'production',
      version: '1.0.0',
    });

    // Clear all mocks
    vi.clearAllMocks();
  });

  afterEach(() => {
    // Restore original environment and process
    process.env = originalEnv;
    Object.assign(process, originalProcess);

    vi.restoreAllMocks();
  });

  describe('GET /api/health', () => {
    it('should return healthy status when all dependencies are connected', async () => {
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('healthy');
      expect(data).toHaveProperty('timestamp');
      expect(data).toHaveProperty('uptime');
      expect(data).toHaveProperty('version');
      expect(data).toHaveProperty('environment');
      expect(data).toHaveProperty('build');
      expect(data).toHaveProperty('dependencies');
      expect(data).toHaveProperty('metrics');
    });

    it('should include correct build information', async () => {
      process.env.VERCEL_GIT_COMMIT_SHA = 'abc123def456';
      
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(data.build.time).toBe('2024-01-01T00:00:00.000Z');
      expect(data.build.commit).toBe('abc123def456');
      expect(data.build.version).toBe('1.0.0');
    });

    it('should include system metrics', async () => {
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(data.metrics).toHaveProperty('memory');
      expect(data.metrics).toHaveProperty('process');

      // Check memory metrics
      expect(data.metrics.memory.used).toBe(60 * 1024 * 1024);
      expect(data.metrics.memory.total).toBe(85 * 1024 * 1024); // heapTotal + external
      expect(data.metrics.memory.percentage).toBe(71); // 60MB / 85MB rounded

      // Check process metrics
      expect(data.metrics.process.pid).toBe(process.pid);
      expect(data.metrics.process.uptime).toBe(3600);
      expect(data.metrics.process.platform).toBe(process.platform);
      expect(data.metrics.process.nodeVersion).toBe(process.version);
    });

    it('should check database connectivity', async () => {
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(data.dependencies).toHaveProperty('database');
      expect(data.dependencies.database.status).toBe('connected');
      expect(data.dependencies.database).toHaveProperty('responseTime');
      expect(data.dependencies.database).toHaveProperty('lastChecked');
    });

    it('should report database as disconnected when configuration is missing', async () => {
      mockConfigService.getDatabaseConfig.mockReturnValue({
        url: null,
        host: null,
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(data.dependencies.database.status).toBe('disconnected');
      expect(data.dependencies.database.error).toContain('Database configuration not found');
    });

    it('should check OpenTelemetry status', async () => {
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(data.dependencies).toHaveProperty('opentelemetry');
      expect(data.dependencies.opentelemetry.status).toBe('connected');
    });

    it('should report OpenTelemetry as degraded when endpoint is missing', async () => {
      mockConfigService.getTelemetryConfig.mockReturnValue({
        isEnabled: true,
        endpoint: null,
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(data.dependencies.opentelemetry.status).toBe('degraded');
      expect(data.dependencies.opentelemetry.error).toContain('OpenTelemetry endpoint not configured');
    });

    it('should return degraded status when some dependencies are degraded', async () => {
      mockConfigService.getTelemetryConfig.mockReturnValue({
        isEnabled: true,
        endpoint: null, // Missing endpoint causes degraded status
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200); // Still operational
      expect(data.status).toBe('degraded');
    });

    it('should return unhealthy status when critical dependencies are disconnected', async () => {
      mockConfigService.getDatabaseConfig.mockReturnValue({
        url: null,
        host: null,
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(503); // Service unavailable
      expect(data.status).toBe('unhealthy');
    });

    it('should use cached results when cache is enabled', async () => {
      const request1 = new NextRequest('http://localhost:3001/api/health');
      const request2 = new NextRequest('http://localhost:3001/api/health');
      
      const response1 = await GET(request1);
      const data1 = await response1.json();
      
      // Second request should use cached result
      const response2 = await GET(request2);
      const data2 = await response2.json();

      expect(data1.timestamp).toBe(data2.timestamp);
      
      // Configuration service should only be called once due to caching
      expect(mockConfigService.getConfiguration).toHaveBeenCalledTimes(1);
    });

    it('should include proper cache control headers', async () => {
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);

      expect(response.headers.get('Cache-Control')).toBe('no-cache, no-store, must-revalidate');
      expect(response.headers.get('Content-Type')).toBe('application/json');
    });

    it('should handle configuration service errors gracefully', async () => {
      mockConfigService.getConfiguration.mockImplementation(() => {
        throw new Error('Configuration service unavailable');
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200); // Should still return a response
      expect(data.environment).toBe('production'); // Should fallback to env vars
      expect(data.serviceName).toBe('test-service');
    });

    it('should return error response when health check fails completely', async () => {
      // Mock process.uptime to throw error
      vi.spyOn(process, 'uptime').mockImplementation(() => {
        throw new Error('Process error');
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(503);
      expect(data.status).toBe('unhealthy');
      expect(data).toHaveProperty('error');
    });

    it('should detect commit SHA from different deployment platforms', async () => {
      // Test Cloudflare Pages
      process.env.CF_PAGES_COMMIT_SHA = 'cf123456';
      delete process.env.VERCEL_GIT_COMMIT_SHA;
      delete process.env.RAILWAY_GIT_COMMIT_SHA;

      let request = new NextRequest('http://localhost:3001/api/health');
      let response = await GET(request);
      let data = await response.json();

      expect(data.build.commit).toBe('cf123456');

      // Test Railway
      delete process.env.CF_PAGES_COMMIT_SHA;
      process.env.RAILWAY_GIT_COMMIT_SHA = 'railway789';

      request = new NextRequest('http://localhost:3001/api/health');
      response = await GET(request);
      data = await response.json();

      expect(data.build.commit).toBe('railway789');
    });

    it('should handle external API checks when enabled', async () => {
      // This test would require enabling external API checks in config
      // For now, they're disabled by default in the health check
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(data.dependencies).toHaveProperty('external_apis');
      expect(data.dependencies.external_apis.status).toBe('unknown');
    });

    it('should include service instance ID from hostname', async () => {
      process.env.HOSTNAME = 'web-server-001';

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      // This would be included in defaultMeta if configuration service works
      expect(mockConfigService.getLoggingConfig).toHaveBeenCalled();
    });
  });

  describe('HEAD /api/ready', () => {
    it('should return 200 when application is healthy', async () => {
      const request = new NextRequest('http://localhost:3001/api/health', { method: 'HEAD' });
      
      const response = await HEAD(request);

      expect(response.status).toBe(200);
      expect(response.body).toBeNull();
    });

    it('should return 503 when application is degraded', async () => {
      mockConfigService.getTelemetryConfig.mockReturnValue({
        isEnabled: true,
        endpoint: null, // Missing endpoint causes degraded status
      });

      const request = new NextRequest('http://localhost:3001/api/health', { method: 'HEAD' });
      
      const response = await HEAD(request);

      expect(response.status).toBe(503);
      expect(response.body).toBeNull();
    });

    it('should return 503 when application is unhealthy', async () => {
      mockConfigService.getDatabaseConfig.mockReturnValue({
        url: null,
        host: null,
      });

      const request = new NextRequest('http://localhost:3001/api/health', { method: 'HEAD' });
      
      const response = await HEAD(request);

      expect(response.status).toBe(503);
      expect(response.body).toBeNull();
    });

    it('should return 503 when health check throws error', async () => {
      vi.spyOn(process, 'uptime').mockImplementation(() => {
        throw new Error('Process error');
      });

      const request = new NextRequest('http://localhost:3001/api/health', { method: 'HEAD' });
      
      const response = await HEAD(request);

      expect(response.status).toBe(503);
      expect(response.body).toBeNull();
    });
  });

  describe('Environment Specific Behavior', () => {
    it('should work in development environment', async () => {
      process.env.NODE_ENV = 'development';
      
      mockConfigService.getConfiguration.mockReturnValue({
        nodeEnv: 'development',
        serviceName: 'test-service-dev',
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.environment).toBe('development');
      expect(data.status).toBe('healthy');
    });

    it('should work in staging environment', async () => {
      process.env.NODE_ENV = 'staging';
      
      mockConfigService.getConfiguration.mockReturnValue({
        nodeEnv: 'staging',
        serviceName: 'test-service-staging',
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.environment).toBe('staging');
    });

    it('should fallback gracefully when configuration service is unavailable', async () => {
      mockConfigService.getConfiguration.mockImplementation(() => {
        throw new Error('Service unavailable');
      });
      mockConfigService.getDatabaseConfig.mockImplementation(() => {
        throw new Error('Service unavailable');
      });
      mockConfigService.getTelemetryConfig.mockImplementation(() => {
        throw new Error('Service unavailable');
      });

      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.environment).toBe('production'); // From process.env
      expect(data.dependencies.database.status).toBe('disconnected');
      expect(data.dependencies.opentelemetry.status).toBe('degraded');
    });
  });

  describe('Performance and Caching', () => {
    it('should complete health check within reasonable time', async () => {
      const start = Date.now();
      
      const request = new NextRequest('http://localhost:3001/api/health');
      const response = await GET(request);
      
      const duration = Date.now() - start;
      
      expect(response.status).toBe(200);
      expect(duration).toBeLessThan(1000); // Should complete within 1 second
    });

    it('should cache results for configured TTL', async () => {
      const request1 = new NextRequest('http://localhost:3001/api/health');
      const request2 = new NextRequest('http://localhost:3001/api/health');
      
      const start = Date.now();
      
      await GET(request1);
      await GET(request2);
      
      const duration = Date.now() - start;
      
      // Second request should be faster due to caching
      expect(duration).toBeLessThan(100); // Should be very fast with cache
    });

    it('should invalidate cache after TTL expires', async () => {
      // This test would require mocking time progression
      // or adjusting cache TTL for testing
      const request = new NextRequest('http://localhost:3001/api/health');
      
      const response = await GET(request);
      const data = await response.json();
      
      expect(data).toHaveProperty('timestamp');
      expect(new Date(data.timestamp).getTime()).toBeCloseTo(Date.now(), -3); // Within 1 second
    });
  });
});